"""Metasploit Framework exploitation wrapper."""

import json
from dataclasses import dataclass, field
from typing import Any

from src.services.security_tools.tool_executor import ToolCategory, ToolConfig, ToolExecutor, get_tool_executor


@dataclass
class MetasploitResult:
    """Metasploit operation results."""
    
    operation_id: str
    operation_type: str
    target: str
    module_used: str
    success: bool
    output: str = ""
    sessions: list[dict[str, Any]] = field(default_factory=list)
    exploited: bool = False
    error_message: str = ""
    summary: str = ""


class MetasploitWrapper:
    """Wrapper for Metasploit Framework."""
    
    def __init__(self):
        """Initialize Metasploit wrapper."""
        self.executor = get_tool_executor()
        
        # Configuration for msfconsole
        self.config = ToolConfig(
            name="metasploit",
            category=ToolCategory.EXPLOITATION,
            command="msfconsole",
            docker_image="metasploitframework/metasploit-framework:latest",
            requires_root=True,
            timeout_seconds=1800,
            max_memory_mb=4096,
            network_access=True,
            allowed_args=[
                "x",  # Execute command
                "q",  # Quiet mode
                "r",  # Resource file
                "o",  # Output file
            ],
            dangerous_args=[],  # Metasploit is inherently dangerous - log everything
        )
    
    async def search_exploits(self, query: str) -> MetasploitResult:
        """Search for exploits matching query.
        
        Args:
            query: Search query (CVE, platform, service, etc.)
        
        Returns:
            MetasploitResult with search results
        """
        # Create resource script
        resource_script = f"""
search {query}
exit
"""
        
        args = [
            "-q",  # Quiet
            "-x", f"search {query}; exit",
        ]
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {"operation": "search", "query": query}
        )
        
        return self._parse_search_results(execution, query)
    
    async def check_vulnerability(
        self,
        target: str,
        port: int,
        module: str,
    ) -> MetasploitResult:
        """Check if target is vulnerable using specific module.
        
        Args:
            target: Target IP address
            port: Target port
            module: Metasploit module path
        
        Returns:
            MetasploitResult indicating if vulnerable
        """
        commands = f"""
use {module}
set RHOSTS {target}
set RPORT {port}
check
exit
"""
        
        args = [
            "-q",
            "-x", commands,
        ]
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {
                "operation": "check",
                "target": target,
                "port": port,
                "module": module,
            }
        )
        
        return self._parse_check_results(execution, target, module)
    
    async def run_auxiliary(
        self,
        module: str,
        target: str,
        options: dict[str, Any] | None = None,
    ) -> MetasploitResult:
        """Run auxiliary module (scanner, fuzzer, etc.).
        
        Args:
            module: Auxiliary module path
            target: Target IP or range
            options: Module options
        
        Returns:
            MetasploitResult
        """
        options = options or {}
        
        commands = [
            f"use {module}",
            f"set RHOSTS {target}",
        ]
        
        # Set additional options
        for key, value in options.items():
            commands.append(f"set {key} {value}")
        
        commands.extend(["run", "exit"])
        command_str = "; ".join(commands)
        
        args = [
            "-q",
            "-x", command_str,
        ]
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {
                "operation": "auxiliary",
                "target": target,
                "module": module,
                "options": options,
            }
        )
        
        return self._parse_auxiliary_results(execution, target, module)
    
    def _parse_search_results(self, execution: Any, query: str) -> MetasploitResult:
        """Parse search results."""
        result = MetasploitResult(
            operation_id=execution.execution_id,
            operation_type="search",
            target="",
            module_used="",
            success=execution.exit_code == 0,
            output=execution.stdout,
        )
        
        # Parse modules from output
        modules = []
        lines = execution.stdout.split("\n")
        
        for line in lines:
            # Look for module paths
            if "exploit/" in line or "auxiliary/" in line or "post/" in line:
                parts = line.split()
                if parts:
                    module_info = {
                        "path": parts[0],
                        "name": " ".join(parts[1:]) if len(parts) > 1 else "",
                    }
                    modules.append(module_info)
        
        result.sessions = modules  # Store modules in sessions field
        result.summary = f"Found {len(modules)} modules matching '{query}'"
        
        return result
    
    def _parse_check_results(self, execution: Any, target: str, module: str) -> MetasploitResult:
        """Parse vulnerability check results."""
        result = MetasploitResult(
            operation_id=execution.execution_id,
            operation_type="check",
            target=target,
            module_used=module,
            success=execution.exit_code == 0,
            output=execution.stdout,
        )
        
        output = execution.stdout.lower()
        
        # Check for vulnerability indicators
        if "appears to be vulnerable" in output or "vulnerable" in output:
            result.exploited = True
            result.summary = f"Target {target} appears VULNERABLE to {module}"
        elif "not vulnerable" in output or "safe" in output:
            result.exploited = False
            result.summary = f"Target {target} does NOT appear vulnerable to {module}"
        else:
            result.summary = f"Could not determine vulnerability status for {target}"
        
        return result
    
    def _parse_auxiliary_results(self, execution: Any, target: str, module: str) -> MetasploitResult:
        """Parse auxiliary module results."""
        result = MetasploitResult(
            operation_id=execution.execution_id,
            operation_type="auxiliary",
            target=target,
            module_used=module,
            success=execution.exit_code == 0,
            output=execution.stdout,
        )
        
        # Extract useful information from output
        findings = []
        lines = execution.stdout.split("\n")
        
        for line in lines:
            if "[+]" in line or "[*]" in line:
                findings.append(line.strip())
        
        result.sessions = [{"finding": f} for f in findings]
        result.summary = f"Auxiliary scan completed. Found {len(findings)} items of interest."
        
        return result


def get_metasploit_wrapper() -> MetasploitWrapper:
    """Get Metasploit wrapper instance."""
    return MetasploitWrapper()
