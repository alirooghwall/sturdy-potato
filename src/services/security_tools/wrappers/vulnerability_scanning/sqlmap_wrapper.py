"""SQLmap SQL injection detection and exploitation wrapper."""

import json
from dataclasses import dataclass, field
from typing import Any

from src.services.security_tools.tool_executor import ToolCategory, ToolConfig, ToolExecutor, get_tool_executor


@dataclass
class SQLMapResult:
    """SQLmap scan results."""
    
    scan_id: str
    target_url: str
    scan_type: str
    injectable: bool
    injection_points: list[dict[str, Any]] = field(default_factory=list)
    databases: list[str] = field(default_factory=list)
    tables: dict[str, list[str]] = field(default_factory=dict)
    dumped_data: dict[str, Any] = field(default_factory=dict)
    dbms: str = ""
    backend_version: str = ""
    vulnerabilities: list[dict[str, Any]] = field(default_factory=list)
    summary: str = ""


class SQLMapWrapper:
    """Wrapper for SQLmap SQL injection tool."""
    
    def __init__(self):
        """Initialize SQLmap wrapper."""
        self.executor = get_tool_executor()
        
        self.config = ToolConfig(
            name="sqlmap",
            category=ToolCategory.VULNERABILITY_SCANNING,
            command="sqlmap",
            docker_image="paoloo/sqlmap:latest",
            requires_root=False,
            timeout_seconds=1800,  # 30 minutes
            max_memory_mb=2048,
            network_access=True,
            allowed_args=[
                "u", "url",  # Target URL
                "d", "data",  # POST data
                "cookie",  # Cookie
                "level",  # Test level (1-5)
                "risk",  # Risk level (1-3)
                "p", "skip",  # Parameters
                "dbms",  # Force DBMS
                "technique",  # SQL injection technique
                "batch",  # Non-interactive
                "threads",  # Number of threads
                "dbs", "tables", "columns", "dump",  # Enumeration
                "current-db", "current-user",
                "output-dir",
                "forms", "crawl",
                "tamper",  # Tamper scripts
            ],
            dangerous_args=["os-cmd", "os-shell", "sql-shell", "file-write", "file-dest"],
        )
    
    async def detect_injection(self, url: str, level: int = 1, risk: int = 1) -> SQLMapResult:
        """Detect SQL injection vulnerabilities.
        
        Args:
            url: Target URL
            level: Test level (1-5, default 1)
            risk: Risk level (1-3, default 1)
        
        Returns:
            SQLMapResult
        """
        args = [
            "--url", url,
            "--batch",  # Non-interactive
            "--level", str(level),
            "--risk", str(risk),
            "--output-dir", "/output",
            "--flush-session",
        ]
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {"scan_type": "detection", "level": level, "risk": risk}
        )
        
        return self._parse_results(execution, url)
    
    async def full_injection_test(
        self,
        url: str,
        data: str | None = None,
        cookie: str | None = None,
        level: int = 3,
        risk: int = 2,
    ) -> SQLMapResult:
        """Comprehensive SQL injection testing.
        
        Args:
            url: Target URL
            data: POST data
            cookie: Cookie string
            level: Test level (1-5)
            risk: Risk level (1-3)
        
        Returns:
            SQLMapResult
        """
        args = [
            "--url", url,
            "--batch",
            "--level", str(level),
            "--risk", str(risk),
            "--output-dir", "/output",
        ]
        
        if data:
            args.extend(["--data", data])
        
        if cookie:
            args.extend(["--cookie", cookie])
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {"scan_type": "full_test", "level": level, "risk": risk}
        )
        
        return self._parse_results(execution, url)
    
    async def enumerate_databases(self, url: str, injectable_param: str | None = None) -> SQLMapResult:
        """Enumerate databases after finding injection.
        
        Args:
            url: Target URL (with injectable parameter)
            injectable_param: Specific parameter to test
        
        Returns:
            SQLMapResult with database list
        """
        args = [
            "--url", url,
            "--batch",
            "--dbs",  # Enumerate databases
            "--output-dir", "/output",
        ]
        
        if injectable_param:
            args.extend(["-p", injectable_param])
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {"scan_type": "enumerate_dbs"}
        )
        
        return self._parse_results(execution, url)
    
    async def enumerate_tables(self, url: str, database: str) -> SQLMapResult:
        """Enumerate tables in a specific database.
        
        Args:
            url: Target URL
            database: Database name
        
        Returns:
            SQLMapResult with table list
        """
        args = [
            "--url", url,
            "--batch",
            "-D", database,
            "--tables",
            "--output-dir", "/output",
        ]
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {"scan_type": "enumerate_tables", "database": database}
        )
        
        return self._parse_results(execution, url)
    
    async def dump_table(
        self,
        url: str,
        database: str,
        table: str,
        columns: list[str] | None = None,
    ) -> SQLMapResult:
        """Dump data from a specific table.
        
        Args:
            url: Target URL
            database: Database name
            table: Table name
            columns: Specific columns to dump
        
        Returns:
            SQLMapResult with dumped data
        """
        args = [
            "--url", url,
            "--batch",
            "-D", database,
            "-T", table,
            "--dump",
            "--output-dir", "/output",
        ]
        
        if columns:
            args.extend(["-C", ",".join(columns)])
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {
                "scan_type": "dump_table",
                "database": database,
                "table": table,
                "columns": columns,
            }
        )
        
        return self._parse_results(execution, url)
    
    async def crawl_and_test(self, url: str, depth: int = 2) -> SQLMapResult:
        """Crawl website and test all found forms.
        
        Args:
            url: Starting URL
            depth: Crawl depth
        
        Returns:
            SQLMapResult
        """
        args = [
            "--url", url,
            "--batch",
            "--crawl", str(depth),
            "--forms",
            "--output-dir", "/output",
        ]
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {"scan_type": "crawl_test", "depth": depth}
        )
        
        return self._parse_results(execution, url)
    
    def _parse_results(self, execution: Any, url: str) -> SQLMapResult:
        """Parse SQLmap output.
        
        Args:
            execution: Tool execution result
            url: Target URL
        
        Returns:
            SQLMapResult
        """
        result = SQLMapResult(
            scan_id=execution.execution_id,
            target_url=url,
            scan_type=execution.metadata.get("scan_type", "unknown"),
            injectable=False,
        )
        
        # Parse output
        output = execution.stdout + execution.stderr
        
        # Check if injection was found
        if "sqlmap identified the following injection point" in output.lower():
            result.injectable = True
            result.injection_points = self._extract_injection_points(output)
        
        # Extract DBMS info
        if "back-end DBMS:" in output.lower():
            result.dbms = self._extract_dbms(output)
        
        # Extract databases
        if "available databases" in output.lower():
            result.databases = self._extract_databases(output)
        
        # Extract tables
        if "database:" in output.lower() and "table" in output.lower():
            result.tables = self._extract_tables(output)
        
        # Generate summary
        result.summary = self._generate_summary(result, output)
        
        return result
    
    def _extract_injection_points(self, output: str) -> list[dict[str, Any]]:
        """Extract injection points from output."""
        points = []
        
        lines = output.split("\n")
        for i, line in enumerate(lines):
            if "Parameter:" in line:
                param_info = {"parameter": line.split("Parameter:")[1].strip()}
                
                # Look for type in next few lines
                for j in range(i, min(i+5, len(lines))):
                    if "Type:" in lines[j]:
                        param_info["type"] = lines[j].split("Type:")[1].strip()
                    if "Title:" in lines[j]:
                        param_info["title"] = lines[j].split("Title:")[1].strip()
                    if "Payload:" in lines[j]:
                        param_info["payload"] = lines[j].split("Payload:")[1].strip()
                
                points.append(param_info)
        
        return points
    
    def _extract_dbms(self, output: str) -> str:
        """Extract DBMS type from output."""
        for line in output.split("\n"):
            if "back-end DBMS:" in line.lower():
                return line.split(":")[-1].strip()
        return "unknown"
    
    def _extract_databases(self, output: str) -> list[str]:
        """Extract database names from output."""
        databases = []
        in_db_section = False
        
        for line in output.split("\n"):
            if "available databases" in line.lower():
                in_db_section = True
                continue
            
            if in_db_section:
                if line.strip().startswith("[*]"):
                    db_name = line.strip()[4:].strip()
                    if db_name:
                        databases.append(db_name)
                elif line.strip() == "" or not line.strip().startswith("["):
                    in_db_section = False
        
        return databases
    
    def _extract_tables(self, output: str) -> dict[str, list[str]]:
        """Extract table names from output."""
        tables = {}
        current_db = None
        
        for line in output.split("\n"):
            if "Database:" in line:
                current_db = line.split("Database:")[1].strip()
                tables[current_db] = []
            elif "Table:" in line and current_db:
                table_name = line.split("Table:")[1].strip()
                tables[current_db].append(table_name)
            elif line.strip().startswith("[*]") and current_db:
                table_name = line.strip()[4:].strip()
                if table_name and table_name not in tables[current_db]:
                    tables[current_db].append(table_name)
        
        return tables
    
    def _generate_summary(self, result: SQLMapResult, output: str) -> str:
        """Generate summary of SQLmap results."""
        parts = [
            f"SQLMap Scan for {result.target_url}",
            f"Scan Type: {result.scan_type}",
            f"Injectable: {'Yes' if result.injectable else 'No'}",
        ]
        
        if result.injectable:
            parts.append(f"Injection Points: {len(result.injection_points)}")
            
            for point in result.injection_points:
                parts.append(f"  - {point.get('parameter', 'unknown')} ({point.get('type', 'unknown')})")
        
        if result.dbms:
            parts.append(f"DBMS: {result.dbms}")
        
        if result.databases:
            parts.append(f"Databases Found: {len(result.databases)}")
            parts.append(f"  {', '.join(result.databases[:5])}")
        
        if result.tables:
            parts.append(f"Tables Found: {sum(len(t) for t in result.tables.values())}")
        
        return "\n".join(parts)


def get_sqlmap_wrapper() -> SQLMapWrapper:
    """Get SQLmap wrapper instance."""
    return SQLMapWrapper()
