"""Nikto web server scanner wrapper."""

import json
import xml.etree.ElementTree as ET
from dataclasses import dataclass, field
from typing import Any

from ..tool_executor import ToolCategory, ToolConfig, ToolExecutor, get_tool_executor


@dataclass
class NiktoResult:
    """Nikto scan results."""
    
    scan_id: str
    target: str
    port: int
    ssl: bool
    findings: list[dict[str, Any]] = field(default_factory=list)
    server_info: dict[str, Any] = field(default_factory=dict)
    vulnerabilities: list[dict[str, Any]] = field(default_factory=list)
    summary: str = ""


class NiktoWrapper:
    """Wrapper for Nikto web server scanner."""
    
    def __init__(self):
        """Initialize Nikto wrapper."""
        self.executor = get_tool_executor()
        
        self.config = ToolConfig(
            name="nikto",
            category=ToolCategory.VULNERABILITY_SCANNING,
            command="nikto",
            docker_image="frapsoft/nikto:latest",
            requires_root=False,
            timeout_seconds=900,
            max_memory_mb=1024,
            network_access=True,
            allowed_args=[
                "h", "host",
                "p", "port",
                "ssl",
                "nossl",
                "Tuning",
                "timeout",
                "maxtime",
                "output",
                "Format",
                "useragent",
                "Plugins",
            ],
            dangerous_args=[],
        )
    
    async def scan_host(
        self,
        host: str,
        port: int = 80,
        ssl: bool = False,
        tuning: str | None = None,
    ) -> NiktoResult:
        """Scan a web server for vulnerabilities.
        
        Args:
            host: Target host
            port: Port number (default 80)
            ssl: Use SSL/TLS
            tuning: Tuning options (e.g., "123" for specific tests)
        
        Returns:
            NiktoResult
        """
        args = [
            "-h", host,
            "-p", str(port),
            "-Format", "xml",
            "-output", "/output/nikto.xml",
        ]
        
        if ssl:
            args.append("-ssl")
        
        if tuning:
            args.extend(["-Tuning", tuning])
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {"host": host, "port": port, "ssl": ssl, "tuning": tuning}
        )
        
        return self._parse_results(execution, host, port, ssl)
    
    async def comprehensive_scan(self, host: str, port: int = 80, ssl: bool = False) -> NiktoResult:
        """Perform comprehensive scan with all tests.
        
        Args:
            host: Target host
            port: Port number
            ssl: Use SSL/TLS
        
        Returns:
            NiktoResult
        """
        args = [
            "-h", host,
            "-p", str(port),
            "-Format", "xml",
            "-output", "/output/nikto.xml",
            "-maxtime", "30m",
        ]
        
        if ssl:
            args.append("-ssl")
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {"host": host, "port": port, "ssl": ssl, "scan_type": "comprehensive"}
        )
        
        return self._parse_results(execution, host, port, ssl)
    
    async def quick_scan(self, host: str, port: int = 80, ssl: bool = False) -> NiktoResult:
        """Quick vulnerability scan (most common issues).
        
        Args:
            host: Target host
            port: Port number
            ssl: Use SSL/TLS
        
        Returns:
            NiktoResult
        """
        # Tuning 1,2,3 = interesting files, misconfigurations, information disclosure
        args = [
            "-h", host,
            "-p", str(port),
            "-Tuning", "123",
            "-Format", "xml",
            "-output", "/output/nikto.xml",
            "-maxtime", "10m",
        ]
        
        if ssl:
            args.append("-ssl")
        
        execution = await self.executor.execute_tool(
            self.config,
            args,
            None,
            {"host": host, "port": port, "ssl": ssl, "scan_type": "quick"}
        )
        
        return self._parse_results(execution, host, port, ssl)
    
    def _parse_results(self, execution: Any, host: str, port: int, ssl: bool) -> NiktoResult:
        """Parse Nikto XML output.
        
        Args:
            execution: Tool execution result
            host: Target host
            port: Port number
            ssl: SSL flag
        
        Returns:
            NiktoResult
        """
        result = NiktoResult(
            scan_id=execution.execution_id,
            target=host,
            port=port,
            ssl=ssl,
        )
        
        # Try to parse XML output
        try:
            # Check for XML in output files or stdout
            xml_content = None
            
            for output_file in execution.output_files:
                if output_file.endswith(".xml"):
                    # TODO: Read file content
                    pass
            
            if not xml_content and "<niktoscan" in execution.stdout:
                xml_content = execution.stdout
            
            if xml_content:
                self._parse_xml(xml_content, result)
        
        except Exception as e:
            result.summary = f"Parse error: {str(e)}\n\n"
        
        # Fallback to text parsing if XML fails
        if not result.findings:
            self._parse_text_output(execution.stdout, result)
        
        result.summary = self._generate_summary(result)
        
        return result
    
    def _parse_xml(self, xml_content: str, result: NiktoResult) -> None:
        """Parse XML output from Nikto."""
        try:
            root = ET.fromstring(xml_content)
            
            # Parse scandetails
            scandetails = root.find(".//scandetails")
            if scandetails is not None:
                result.server_info = {
                    "targetip": scandetails.get("targetip"),
                    "targethostname": scandetails.get("targethostname"),
                    "targetport": scandetails.get("targetport"),
                    "targetbanner": scandetails.get("targetbanner"),
                    "starttime": scandetails.get("starttime"),
                }
            
            # Parse items (findings)
            for item in root.findall(".//item"):
                finding = {
                    "id": item.get("id"),
                    "osvdb_id": item.get("osvdbid"),
                    "method": item.get("method"),
                    "uri": item.get("uri"),
                    "description": item.findtext("description", ""),
                    "namelink": item.findtext("namelink", ""),
                    "iplink": item.findtext("iplink", ""),
                }
                
                result.findings.append(finding)
                
                # Categorize as vulnerability if OSVDB ID or certain keywords
                if (finding.get("osvdb_id") and finding["osvdb_id"] != "0") or \
                   any(keyword in finding["description"].lower() for keyword in [
                       "vulnerable", "exploit", "xss", "sql injection", "directory traversal"
                   ]):
                    result.vulnerabilities.append(finding)
        
        except ET.ParseError:
            pass
    
    def _parse_text_output(self, output: str, result: NiktoResult) -> None:
        """Parse text output as fallback."""
        lines = output.split("\n")
        
        for line in lines:
            # Look for + lines which indicate findings
            if line.strip().startswith("+"):
                finding = {
                    "description": line.strip()[1:].strip(),
                    "source": "text_output",
                }
                result.findings.append(finding)
                
                # Basic vulnerability detection
                if any(keyword in line.lower() for keyword in [
                    "vulnerable", "outdated", "misconfigur", "xss", "sql"
                ]):
                    result.vulnerabilities.append(finding)
    
    def _generate_summary(self, result: NiktoResult) -> str:
        """Generate summary of findings."""
        parts = [
            f"Nikto Scan Results for {result.target}:{result.port}",
            f"SSL: {'Yes' if result.ssl else 'No'}",
            f"Total Findings: {len(result.findings)}",
            f"Potential Vulnerabilities: {len(result.vulnerabilities)}",
        ]
        
        if result.server_info.get("targetbanner"):
            parts.append(f"Server: {result.server_info['targetbanner']}")
        
        if result.vulnerabilities:
            parts.append("\nTop Vulnerabilities:")
            for vuln in result.vulnerabilities[:5]:
                desc = vuln.get("description", "")[:100]
                parts.append(f"  - {desc}")
        
        return "\n".join(parts)


def get_nikto_wrapper() -> NiktoWrapper:
    """Get Nikto wrapper instance."""
    return NiktoWrapper()
